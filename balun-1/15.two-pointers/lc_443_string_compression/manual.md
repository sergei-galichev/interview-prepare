[443. String Compression](https://leetcode.com/problems/string-compression/)

```go
package main

func compress(chars []byte) int {
	idx1 := 0
	idx2 := 0

	for idx2 < len(chars) {
		groupSize := 1

		for groupSize+idx2 < len(chars) && chars[idx2] == chars[idx2+groupSize] {
			groupSize++
		}

		chars[idx1] = chars[idx2]
		idx1++

		if groupSize > 1 {
			for _, digit := range strconv.Itoa(groupSize) {
				chars[idx1] = byte(digit)

				idx1++
			}
		}

		idx2 += groupSize
	}

	return idx1
}
```

***Оценка по времени:*** `O(n)`

*Объяснения:* 1 проход по слайсу

***Оценка по памяти:*** `O(1)`

*Объяснения:* дополнительной памяти не выделяется

**Описание решения**

Создаем два индекса. В цикле идем по слайсу пока 2-й индекс меньше длины слайса. Будем подсчитывать размер группы. На
каждом шаге цикла устанавливаем его в 1. Элементу по 1-му индексу присвоим значение элемента по 2-му индексу и сдвинем 
1-й индекс вперед на 1. Если размер группы больше 1, то запишем число в элемент по 1-му по индексу. Также 
предусматриваем, что число можем иметь более 1-й цифры. 2-й индекс смещаем на размер группы. Возвращаем 1-й индекс, т.к.
он равен количеству элементов по сжатия, не учитывая далее идущих символов. 